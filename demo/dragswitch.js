// Generated by CoffeeScript 1.3.3
(function() {

  KISSY.add("widget/dragswitch", function(S, Node, Event, UA, SSlog) {
    var $, DragSwitch, defaultConfig;
    $ = KISSY.all;
    defaultConfig = {
      distance: 6,
      angle: Math.PI / 6,
      checkvalid: null,
      inertiaMove: false,
      disable: false,
      binds: [
        null, null, null, null, {
          moveEls: [],
          maxDistance: 99999,
          validDistance: null,
          passCallback: null,
          failCallback: null,
          checkvalid: null
        }
      ]
    };
    return DragSwitch = (function() {

      function DragSwitch(el, config) {
        this.el = el;
        this.config = config;
        S.mix(this, S.EventTarget);
        this.init();
      }

      DragSwitch.prototype.init = function() {
        var el, item, _i, _j, _len, _len1, _ref, _ref1;
        this.config = S.merge(defaultConfig, this.config);
        this.disable = this.config.disable;
        if (typeof this.el === "string") {
          this.isSelector = true;
        }
        if (!this.isSelector) {
          this.el = $(this.el);
        }
        this.tanAngel = Math.tan(this.config.angle);
        this.effectEls = [];
        _ref = this.config.binds;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (!item) {
            continue;
          }
          if (!item.moveEls.join("")) {
            item.moveEls = [this.el];
            this.effectEls.push($(this.el));
          } else {
            _ref1 = item.moveEls;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              el = _ref1[_j];
              this.effectEls.push($(el));
            }
          }
        }
        return this.bindEvents();
      };

      DragSwitch.prototype.bindEvents = function() {
        var _this = this;
        if (this.isSelector) {
          $('body').delegate("touchstart", this.el, function(ev) {
            return _this.touchStart(ev);
          });
          $('body').delegate("touchmove", this.el, function(ev) {
            return _this.touchMove(ev);
          });
          return $('body').delegate("touchend", this.el, function(ev) {
            return _this.touchEnd(ev);
          });
        } else {
          this.el.on("touchstart", function(ev) {
            return _this.touchStart(ev);
          });
          this.el.on("touchmove", function(ev) {
            return _this.touchMove(ev);
          });
          return this.el.on("touchend", function(ev) {
            return _this.touchEnd(ev);
          });
        }
      };

      DragSwitch.prototype.touchStart = function(ev) {
        if (this.disable) {
          return;
        }
        this.enabled = this.config.checkvalid ? this.config.checkvalid() : true;
        if (!this.enabled) {
          return;
        }
        ev.halt();
        ev = ev.originalEvent;
        this.istouchStart = true;
        this.isSendStart = false;
        this.eventType = null;
        this.key = null;
        this.startPoint = [ev.touches[0].pageX, ev.touches[0].pageY];
        this.lastPoint = this.startPoint.slice();
        this.yesterPoint = this.lastPoint.slice();
        return this.saveMatrixState();
      };

      DragSwitch.prototype.touchMove = function(e) {
        var angleDelta, distance, ev, maxDistance, oPoint, point;
        if (!this.istouchStart) {
          return;
        }
        ev = e.originalEvent;
        point = [ev.touches[0].pageX, ev.touches[0].pageY];
        oPoint = this.startPoint;
        angleDelta = Math.abs((oPoint[1] - point[1]) / (point[0] - oPoint[0]));
        distance = [oPoint[0] - point[0], oPoint[1] - point[1]];
        maxDistance = Math.max(Math.abs(distance[0]), Math.abs(distance[1]));
        if (!this.isSendStart && angleDelta > this.tanAngel && 1 / angleDelta > this.tanAngel) {
          this.istouchStart = false;
          return;
        } else if (!this.eventType && maxDistance >= this.config.distance) {
          if (angleDelta <= this.tanAngel) {
            this.eventType = (distance[0] > 0 ? "dragRight" : "dragLeft");
          } else if (1 / angleDelta <= this.tanAngel) {
            this.eventType = (distance[1] > 0 ? "dragUp" : "dragDown");
          } else {
            this.eventType = null;
          }
          this.key = (this.eventType === "dragUp" ? 0 : (this.eventType === "dragRight" ? 1 : (this.eventType === "dragDown" ? 2 : (this.eventType === "dragLeft" ? 3 : null))));
          this.obbKey = 1 - this.key % 2;
          this.effectBind = this.config.binds[this.key];
          this.moveEls = this.effectBind.moveEls;
          this.enabled = this.effectBind.checkvalid ? this.effectBind.checkvalid() : true;
          this.startTime = new Date;
          $("body").addClass("dragswitch-dragging");
        }
        if (!this.eventType || !this.enabled) {
          return;
        }
        if (!this.isSendStart) {
          this.fire(this.eventType + "Start", S.mix(e, {
            self: this
          }));
          this.isSendStart = true;
        }
        this.fire(this.eventType, S.mix(e, {
          self: this
        }));
        if (!e.isDefaultPrevented()) {
          this.move(point);
        }
        this.yesterPoint = this.lastPoint.slice();
        this.yesterTime = new Date(this.lastTime);
        this.lastPoint = point.slice();
        return this.lastTime = new Date;
      };

      DragSwitch.prototype.touchEnd = function(e) {
        var v;
        $("body").removeClass("dragswitch-dragging");
        if (this.istouchStart && this.isSendStart) {
          if (!this.config.inertiaMove) {
            this.touchEndHandler(e);
          } else {
            v = (this.yesterPoint[this.obbKey] - this.lastPoint[this.obbKey]) / (this.yesterTime - this.lastTime);
          }
        }
        this.istouchStart = false;
        return this.isSendStart = false;
      };

      DragSwitch.prototype.touchEndHandler = function(e) {
        var obj;
        this.fire(this.eventType + "End", S.mix(e, {
          self: this
        }));
        obj = this.effectBind;
        if (Math.abs(this.distance) >= obj.validDistance) {
          if (obj.passCallback) {
            return obj.passCallback.call(e.target, S.mix(e, {
              self: this
            }));
          }
        } else {
          return this.restoreMatrixState();
        }
      };

      DragSwitch.prototype.saveMatrixState = function() {
        var el, _i, _len, _ref, _results;
        _ref = this.effectEls;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          el = _ref[_i];
          _results.push(el.matrixState = this.getMatrix(el));
        }
        return _results;
      };

      DragSwitch.prototype.getMatrix = function(el) {
        return $(el).css("-webkit-transform") || $(el).css("-o-transform") || $(el).css("transform");
      };

      DragSwitch.prototype.setMatrix = function(el, matrix) {
        return $(el).css({
          "transform": matrix,
          "-webkit-transform": matrix,
          "-ms-transform": matrix,
          "-o-transform": matrix
        });
      };

      DragSwitch.prototype.restoreMatrixState = function() {
        var el, _i, _len, _ref, _results;
        _ref = this.effectEls;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          el = _ref[_i];
          _results.push(this.setMatrix(el, el.matrixState));
        }
        return _results;
      };

      DragSwitch.prototype.move = function(endPoint) {
        var currentMatrix, distance, el, key, lastPoint, rawDistance, startPoint, _i, _len, _ref, _results;
        key = this.key;
        startPoint = this.startPoint;
        lastPoint = this.lastPoint;
        rawDistance = this.distance = (key % 2 === 0 ? endPoint[1] - startPoint[1] : endPoint[0] - startPoint[0]);
        distance = (key % 2 === 0 ? endPoint[1] - lastPoint[1] : endPoint[0] - lastPoint[0]);
        if (!this.effectBind || this.effectBind.maxDistance < Math.abs(rawDistance)) {
          return;
        }
        _ref = this.moveEls;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          el = _ref[_i];
          currentMatrix = this.getMatrix(el);
          _results.push(this.setMatrix(el, this.translate(currentMatrix, distance, key % 2)));
        }
        return _results;
      };

      DragSwitch.prototype.translate = function(currentMatrix, distance, hori) {
        var matrix;
        matrix = currentMatrix.match(/[0-9\.\-]+/g);
        if (!matrix) {
          matrix = [1, 0, 0, 1, 0, 0];
        }
        matrix.forEach(function(item, key) {
          return matrix[key] = parseFloat(item);
        });
        matrix[4] += distance * hori;
        matrix[5] += distance * (1 - hori);
        return "matrix(" + matrix.join(',') + ")";
      };

      return DragSwitch;

    })();
  }, {
    requires: ["node", "event", "ua", "widget/sslog"]
  });

}).call(this);
